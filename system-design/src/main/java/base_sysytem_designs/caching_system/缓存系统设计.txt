缓存设计选型:
1. 数据量小，并且不会频繁地增长又清空: 本地缓存
2. 如果需要一些策略的支持(比如缓存逐出策略): Ehcache
3. 如果不要缓存逐出: HashMap
4. 如需要考虑多线程并发的场景，可以考虑ConcurrentHashMap

TODO. 如何解决缓存满的问题 ？
理论上随着缓存数据的日益增多，在容量有限的情况下缓存肯定会满。
1. 选择合适的缓存逐出算法，比如最常见的LRU
2. 设置适当的警戒值，比如10G的缓存，当缓存数据达到8G时就开始报警，提前排查问题或者扩容
3. 给一些没有必要长期保存的key，尽量设置过期时间Expiration

TODO. 缓存实际案例
同一个软件的同一UI被不同的User更改，在数据刷新上如何变更Cache中的数据，
如果在短时间内，缓存的数并没有变化会造成UI页面显示的数据出错
- Invalid机制
- Event Listener机制(Publisher)

在数据变更时(Add/Update/Delete)
- 废弃缓存中的错误数据
- 执行额外的request并发布通知事件
